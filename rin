#!/bin/bash
set -e

# Rhyzomic Intelligence Node (RIN) - CLI Management Tool
# Version: 1.2.1
# Description: Comprehensive CLI for managing RIN lifecycle

# --- Color Definitions ---
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# --- Base Directory ---
BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- Helper Functions ---

print_header() {
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
    echo -e "${BLUE}ðŸ§  RIN - $1${NC}"
    echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
}

print_success() {
    echo -e "${GREEN}âœ“ $1${NC}"
}

print_info() {
    echo -e "${BLUE}â„¹ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš  $1${NC}"
}

print_error() {
    echo -e "${RED}âœ— $1${NC}"
}

check_docker() {
    if ! command -v docker &> /dev/null; then
        print_error "Docker not found. Please install Docker first."
        echo "Run: curl -fsSL https://get.docker.com | sh"
        exit 1
    fi
    
    if ! docker info >/dev/null 2>&1; then
        print_error "Docker is not running. Please start Docker and try again."
        exit 1
    fi
}

confirm_action() {
    local message="$1"
    local response
    
    echo -e "${YELLOW}$message${NC}"
    read -p "Continue? (y/n) " -n 1 -r response
    echo
    
    if [[ ! $response =~ ^[Yy]$ ]]; then
        return 1
    fi
    return 0
}

validate_base_dir() {
    # Ensure BASE_DIR is set and is a valid directory
    if [ -z "$BASE_DIR" ]; then
        print_error "BASE_DIR is not set. This is a critical error."
        exit 1
    fi
    
    # Ensure BASE_DIR looks like the RIN directory (has docker-compose.yml)
    if [ ! -f "$BASE_DIR/docker-compose.yml" ]; then
        print_error "BASE_DIR does not appear to be a valid RIN directory."
        print_error "Expected docker-compose.yml in: $BASE_DIR"
        exit 1
    fi
}

load_env() {
    if [ -f "$BASE_DIR/.env" ]; then
        # Safely load PORT_ variables from .env
        while IFS='=' read -r key value; do
            # Skip comments and empty lines (including whitespace before comments)
            [[ "$key" =~ ^[[:space:]]*# ]] && continue
            [[ "$key" =~ ^[[:space:]]*$ ]] && continue
            # Only load PORT_ variables
            if [[ "$key" =~ ^PORT_ ]]; then
                # Remove any quotes and export
                value=$(echo "$value" | sed 's/^["'\'']\|["'\'']$//g')
                export "$key=$value"
            fi
        done < "$BASE_DIR/.env"
    fi
}

# --- Command Implementations ---

cmd_start() {
    print_header "Starting RIN"
    
    # Execute the original start.sh script
    if [ -f "$BASE_DIR/start.sh" ]; then
        "$BASE_DIR/start.sh"
    else
        print_error "start.sh not found in $BASE_DIR"
        exit 1
    fi
}

cmd_stop() {
    print_header "Stopping RIN"
    check_docker
    
    cd "$BASE_DIR"
    
    if ! docker compose ps --quiet | grep -q .; then
        print_warning "RIN is not running"
        exit 0
    fi
    
    print_info "Shutting down all subsystems..."
    docker compose down
    
    print_success "RIN stopped successfully"
}

cmd_restart() {
    print_header "Restarting RIN"
    
    cmd_stop
    echo ""
    cmd_start
}

cmd_status() {
    print_header "RIN System Status"
    check_docker
    load_env
    
    cd "$BASE_DIR"
    
    if ! docker compose ps --quiet | grep -q .; then
        print_warning "RIN is not running"
        echo ""
        echo "Start RIN with: ./rin start"
        exit 0
    fi
    
    echo ""
    echo "Container Status:"
    docker compose ps
    
    echo ""
    echo "Service Health:"
    
    # Define services with their health endpoints
    declare -A services
    services["Open WebUI (Cortex)"]="http://localhost:${PORT_WEBUI:-3000}"
    services["LiteLLM (Router)"]="http://localhost:${PORT_LITELLM:-4000}/health"
    services["SearXNG (Vision)"]="http://localhost:${PORT_SEARXNG:-8080}"
    services["FireCrawl (Digestion)"]="http://localhost:${PORT_FIRECRAWL:-3002}"
    services["n8n (Reflex)"]="http://localhost:${PORT_N8N:-5678}"
    services["Qdrant (Memory)"]="http://localhost:${PORT_QDRANT:-6333}"
    
    for service in "${!services[@]}"; do
        url="${services[$service]}"
        if curl -s -f -o /dev/null -m 2 "$url" 2>/dev/null; then
            print_success "$service: $url"
        else
            print_error "$service: $url (not responding)"
        fi
    done
    
    echo ""
    echo "Quick Access:"
    echo "  ðŸ§  Cortex:     http://localhost:${PORT_WEBUI:-3000}"
    echo "  ðŸ”„ Reflex:     http://localhost:${PORT_N8N:-5678}"
    echo "  ðŸ” Vision:     http://localhost:${PORT_SEARXNG:-8080}"
    
    echo ""
    echo "API Keys Configuration:"
    
    # Check for .env file
    if [ -f "$BASE_DIR/.env" ]; then
        # Check TAVILY_API_KEY
        TAVILY_KEY=$(grep "^TAVILY_API_KEY=" "$BASE_DIR/.env" 2>/dev/null | cut -d '=' -f2 | tr -d ' ')
        if [ -n "$TAVILY_KEY" ] && [ "$TAVILY_KEY" != "" ]; then
            print_success "  Tavily Search: Configured âœ“ (tavily_search.py available)"
        else
            print_warning "  Tavily Search: Not configured (add TAVILY_API_KEY to .env)"
        fi
        
        # Check FIRECRAWL configuration
        FIRECRAWL_URL=$(grep "^FIRECRAWL_API_URL=" "$BASE_DIR/.env" 2>/dev/null | cut -d '=' -f2 | tr -d ' ')
        if [ -n "$FIRECRAWL_URL" ] && [ "$FIRECRAWL_URL" != "" ]; then
            print_success "  FireCrawl: Cloud API mode âœ“ (firecrawl_scraper.py)"
        else
            print_success "  FireCrawl: Self-hosted mode âœ“ (firecrawl_scraper.py)"
        fi
        
        # Check OPENAI_API_KEY
        OPENAI_KEY=$(grep "^OPENAI_API_KEY=" "$BASE_DIR/.env" 2>/dev/null | cut -d '=' -f2 | tr -d ' ')
        if [ -n "$OPENAI_KEY" ] && [ "$OPENAI_KEY" != "" ]; then
            print_success "  OpenAI: Configured âœ“"
        else
            print_warning "  OpenAI: Not configured (add OPENAI_API_KEY to .env)"
        fi
        
        # Check ANTHROPIC_API_KEY
        ANTHROPIC_KEY=$(grep "^ANTHROPIC_API_KEY=" "$BASE_DIR/.env" 2>/dev/null | cut -d '=' -f2 | tr -d ' ')
        if [ -n "$ANTHROPIC_KEY" ] && [ "$ANTHROPIC_KEY" != "" ]; then
            print_success "  Anthropic: Configured âœ“"
        else
            print_warning "  Anthropic: Not configured (add ANTHROPIC_API_KEY to .env)"
        fi
    else
        print_error "  .env file not found. Run ./rin start to initialize."
    fi
    
    echo ""
    echo "Tools Available in Open WebUI:"
    echo "  ðŸ“¦ searxng_search.py    - Anonymous web search"
    echo "  ðŸ“¦ tavily_search.py     - AI-optimized search (requires TAVILY_API_KEY)"
    echo "  ðŸ“¦ firecrawl_scraper.py - Web scraping (self-hosted or cloud)"
    echo "  ðŸ“¦ qdrant_memory.py     - Long-term memory with RAG"
    echo "  ðŸ“¦ n8n_reflex.py        - Workflow automation"
}

cmd_logs() {
    print_header "RIN Logs"
    check_docker
    
    cd "$BASE_DIR"
    
    local service="$1"
    local follow="${2:-false}"
    
    if [ -z "$service" ]; then
        # Show all logs
        if [ "$follow" = "true" ] || [ "$follow" = "-f" ]; then
            docker compose logs -f
        else
            docker compose logs --tail=50
        fi
    else
        # Show specific service logs
        if [ "$follow" = "true" ] || [ "$follow" = "-f" ]; then
            docker compose logs -f "$service"
        else
            docker compose logs --tail=50 "$service"
        fi
    fi
}

cmd_update() {
    print_header "Updating RIN"
    check_docker
    
    cd "$BASE_DIR"
    
    print_info "Pulling latest Docker images..."
    docker compose pull
    
    print_success "Images updated successfully"
    print_info "Run './rin restart' to apply updates"
}

cmd_upgrade() {
    print_header "Upgrading RIN"
    check_docker
    
    cd "$BASE_DIR"
    
    # Check if we're in a git repository
    if [ ! -d .git ]; then
        print_error "Not a git repository. Cannot upgrade."
        print_info "To upgrade manually:"
        print_info "  1. Backup your data: ./rin backup"
        print_info "  2. Download the latest release"
        print_info "  3. Restore your data: ./rin restore"
        exit 1
    fi
    
    # Save current branch
    current_branch=$(git branch --show-current)
    
    print_info "Fetching latest changes from repository..."
    git fetch origin
    
    print_info "Current branch: $current_branch"
    
    # Check for updates
    if git diff --quiet HEAD origin/$current_branch; then
        print_success "Already up to date"
        exit 0
    fi
    
    print_warning "Updates available. This will pull the latest code."
    
    if ! confirm_action "âš  This will update RIN code and Docker images."; then
        print_info "Upgrade cancelled"
        exit 0
    fi
    
    # Stop services before upgrading
    print_info "Stopping services..."
    docker compose down
    
    # Pull latest code
    print_info "Pulling latest code..."
    git pull origin "$current_branch"
    
    # Update Docker images
    print_info "Updating Docker images..."
    docker compose pull
    
    print_success "Upgrade completed successfully"
    print_info "Start RIN with: ./rin start"
}

cmd_backup() {
    print_header "Backing Up RIN Data"
    
    local backup_dir="${1:-$BASE_DIR/backups/$(date +%Y%m%d_%H%M%S)}"
    
    print_info "Creating backup in: $backup_dir"
    
    mkdir -p "$backup_dir"
    
    # Backup data directories
    if [ -d "$BASE_DIR/data" ]; then
        print_info "Backing up data directory..."
        cp -r "$BASE_DIR/data" "$backup_dir/"
    fi
    
    # Backup .env file
    if [ -f "$BASE_DIR/.env" ]; then
        print_info "Backing up .env file..."
        cp "$BASE_DIR/.env" "$backup_dir/"
    fi
    
    # Backup config directory
    if [ -d "$BASE_DIR/config" ]; then
        print_info "Backing up config directory..."
        cp -r "$BASE_DIR/config" "$backup_dir/"
    fi
    
    # Backup workflows
    if [ -d "$BASE_DIR/workflows" ]; then
        print_info "Backing up workflows..."
        cp -r "$BASE_DIR/workflows" "$backup_dir/"
    fi
    
    # Create backup manifest
    cat <<EOF > "$backup_dir/backup_manifest.txt"
RIN Backup Manifest
Created: $(date)
Version: 1.2.1

Contents:
- data/          (All service data)
- .env           (Environment configuration)
- config/        (Service configurations)
- workflows/     (n8n workflows)
EOF
    
    print_success "Backup completed: $backup_dir"
}

cmd_restore() {
    print_header "Restoring RIN Data"
    
    # Validate BASE_DIR first
    validate_base_dir
    
    local backup_dir="$1"
    
    if [ -z "$backup_dir" ]; then
        print_error "Please specify backup directory"
        echo "Usage: ./rin restore <backup_directory>"
        exit 1
    fi
    
    if [ ! -d "$backup_dir" ]; then
        print_error "Backup directory not found: $backup_dir"
        exit 1
    fi
    
    # Verify backup integrity
    if [ ! -f "$backup_dir/backup_manifest.txt" ]; then
        print_error "Invalid backup: backup_manifest.txt not found"
        exit 1
    fi
    
    print_info "Backup verification:"
    cat "$backup_dir/backup_manifest.txt"
    echo ""
    
    if ! confirm_action "âš  This will overwrite current data with backup."; then
        print_info "Restore cancelled"
        exit 0
    fi
    
    # Stop services before restoring
    print_info "Stopping services..."
    docker compose down 2>/dev/null || true
    
    # Create safety backup of current data
    if [ -d "$BASE_DIR/data" ]; then
        local safety_backup="$BASE_DIR/data.pre-restore.$(date +%Y%m%d_%H%M%S)"
        print_info "Creating safety backup of current data: $safety_backup"
        cp -r "$BASE_DIR/data" "$safety_backup"
    fi
    
    # Restore data (with BASE_DIR validation already done)
    if [ -d "$backup_dir/data" ]; then
        print_info "Restoring data directory..."
        rm -rf "$BASE_DIR/data"
        cp -r "$backup_dir/data" "$BASE_DIR/"
    fi
    
    # Restore .env
    if [ -f "$backup_dir/.env" ]; then
        print_info "Restoring .env file..."
        cp "$backup_dir/.env" "$BASE_DIR/"
    fi
    
    # Restore config (with BASE_DIR validation already done)
    if [ -d "$backup_dir/config" ]; then
        print_info "Restoring config directory..."
        rm -rf "$BASE_DIR/config"
        cp -r "$backup_dir/config" "$BASE_DIR/"
    fi
    
    # Restore workflows (with BASE_DIR validation already done)
    if [ -d "$backup_dir/workflows" ]; then
        print_info "Restoring workflows..."
        rm -rf "$BASE_DIR/workflows"
        cp -r "$backup_dir/workflows" "$BASE_DIR/"
    fi
    
    print_success "Restore completed successfully"
    print_info "Start RIN with: ./rin start"
}

cmd_ps() {
    print_header "RIN Containers"
    check_docker
    
    cd "$BASE_DIR"
    docker compose ps
}

cmd_exec() {
    check_docker
    
    local service="$1"
    shift
    
    if [ -z "$service" ]; then
        print_error "Please specify a service"
        echo "Usage: ./rin exec <service> <command>"
        echo ""
        echo "Available services:"
        echo "  open-webui    - Open WebUI (Cortex)"
        echo "  litellm       - LiteLLM (Router)"
        echo "  searxng       - SearXNG (Vision)"
        echo "  firecrawl     - FireCrawl (Digestion)"
        echo "  n8n           - n8n (Reflex)"
        echo "  qdrant        - Qdrant (Memory)"
        echo "  redis         - Redis (Nervous System)"
        exit 1
    fi
    
    cd "$BASE_DIR"
    
    if [ $# -eq 0 ]; then
        # No command provided, start interactive shell
        docker compose exec "$service" /bin/sh
    else
        # Execute provided command
        docker compose exec "$service" "$@"
    fi
}

cmd_clean() {
    print_header "Cleaning RIN"
    
    print_warning "This will remove all containers, volumes, and images."
    print_warning "Your data in the data/ directory will be preserved."
    
    if ! confirm_action "âš  This is a destructive operation."; then
        print_info "Clean cancelled"
        exit 0
    fi
    
    check_docker
    cd "$BASE_DIR"
    
    print_info "Stopping and removing containers..."
    docker compose down -v
    
    print_info "Removing Docker images..."
    docker compose down --rmi all 2>/dev/null || true
    
    print_success "Cleanup completed"
}

cmd_version() {
    print_header "RIN Version"
    
    echo "RIN Version: 1.2.1"
    echo "CLI Tool: v1.0.0"
    echo ""
    
    if [ -d .git ]; then
        echo "Git Branch: $(git branch --show-current 2>/dev/null || echo 'unknown')"
        echo "Git Commit: $(git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
    fi
}

cmd_models_sync() {
    print_header "Syncing OpenRouter Models"
    
    validate_base_dir
    
    # Check if sync script exists
    if [ ! -f "$BASE_DIR/scripts/sync_openrouter_models.py" ]; then
        print_error "Model sync script not found"
        exit 1
    fi
    
    # Run sync script
    python3 "$BASE_DIR/scripts/sync_openrouter_models.py"
    
    if [ $? -eq 0 ]; then
        print_success "Models synced successfully"
        print_info "Restart LiteLLM to apply changes: ./rin restart litellm"
    else
        print_error "Model sync failed"
        exit 1
    fi
}

cmd_models_search() {
    validate_base_dir
    
    # Check if search script exists
    if [ ! -f "$BASE_DIR/scripts/search_models.py" ]; then
        print_error "Model search script not found"
        exit 1
    fi
    
    # Pass all arguments to search script
    python3 "$BASE_DIR/scripts/search_models.py" "$@"
}

cmd_models_list() {
    print_header "Available Models"
    
    validate_base_dir
    
    local limit="${1:-50}"  # Default limit to 50
    local filter="${2:-all}" # Default show all
    
    # Check if config exists
    local config_path="$BASE_DIR/config/litellm/config.yaml"
    if [ ! -f "$config_path" ]; then
        print_error "LiteLLM config not found"
        exit 1
    fi
    
    # Use helper script to safely parse and display models
    python3 "$BASE_DIR/scripts/list_models_helper.py" "$config_path" "$limit" "$filter"
}

cmd_models_recommend() {
    print_header "Model Recommendations"
    
    validate_base_dir
    
    local recommendations_file="$BASE_DIR/data/model_recommendations.json"
    
    if [ ! -f "$recommendations_file" ]; then
        print_warning "No recommendations found. Run './rin models sync' first."
        exit 1
    fi
    
    # Use Python to parse and display recommendations
    python3 << EOF
import json
import sys

try:
    with open('$recommendations_file', 'r') as f:
        recs = json.load(f)
    
    categories = {
        'best_value': 'ðŸ’Ž Best Value',
        'most_capable': 'ðŸš€ Most Capable',
        'fastest': 'âš¡ Fastest',
        'budget_friendly': 'ðŸ’° Budget Friendly',
        'vision_tasks': 'ðŸ‘ï¸  Vision Tasks',
        'coding': 'ðŸ’» Coding'
    }
    
    for key, title in categories.items():
        models = recs.get(key, [])
        if models:
            print(f"\n{title}:")
            for i, model in enumerate(models[:3], 1):
                print(f"  {i}. {model}")
    
    print()

except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
EOF
}

cmd_models_top() {
    local count="${1:-10}"
    
    print_header "Top $count Models"
    
    cmd_models_list "$count" "popular"
}

cmd_models_filter() {
    local filter="${1:-all}"
    local limit="${2:-50}"
    
    print_header "Models Filtered by: $filter"
    
    cmd_models_list "$limit" "$filter"
}

cmd_models() {
    local subcommand="${1:-help}"
    shift || true
    
    case "$subcommand" in
        sync)
            cmd_models_sync "$@"
            ;;
        search)
            cmd_models_search "$@"
            ;;
        list)
            cmd_models_list "$@"
            ;;
        top)
            cmd_models_top "$@"
            ;;
        filter)
            cmd_models_filter "$@"
            ;;
        recommend|recommendations)
            cmd_models_recommend "$@"
            ;;
        help|--help|-h)
            cat <<EOF
Model Management Commands

USAGE:
    ./rin models <subcommand> [options]

SUBCOMMANDS:
    sync                    Sync latest models from OpenRouter API
    search <query>          Search models by criteria
    list [limit] [filter]   List available models (default: 50)
    top [count]             Show top N models by popularity (default: 10)
    filter <type> [limit]   Filter models by type (openrouter, popular, budget, vision, etc.)
    recommend               Show model recommendations
    help                    Show this help message

EXAMPLES:
    ./rin models sync                      # Sync all models
    ./rin models list 25                   # List top 25 models
    ./rin models top 10                    # Show top 10 models
    ./rin models filter vision 20          # Show 20 vision models
    ./rin models filter budget 30          # Show 30 budget models
    ./rin models search --tag vision       # Search for vision models
    ./rin models recommend                 # Show recommendations

FILTERS:
    all            - All models
    openrouter     - OpenRouter models only
    popular        - High popularity models (score >= 70)
    budget         - Budget tier models
    vision         - Vision capability models
    function-calling - Function calling models
    openai         - OpenAI models
    anthropic      - Anthropic models

For more information, see: docs/DYNAMIC_MODELS.md
EOF
            ;;
        *)
            print_error "Unknown models subcommand: $subcommand"
            echo ""
            echo "Run './rin models help' for usage information"
            exit 1
            ;;
    esac
}

cmd_help() {
    cat <<EOF
Rhyzomic Intelligence Node (RIN) - CLI Management Tool

USAGE:
    ./rin <command> [options]

COMMANDS:
    start               Start all RIN services
    stop                Stop all RIN services
    restart             Restart all RIN services
    status              Show status of all services
    logs [service] [-f] View logs (optionally follow with -f)
    update              Pull latest Docker images
    upgrade             Upgrade RIN to latest version
    backup [dir]        Backup RIN data
    restore <dir>       Restore RIN data from backup
    ps                  List all running containers
    exec <service> [cmd] Execute command in service container
    clean               Remove all containers and images
    models              Model management (sync, search, list, filter, etc.)
    version             Show version information
    help                Show this help message

MODEL MANAGEMENT:
    models sync                 Sync latest models from OpenRouter
    models list [N] [filter]    List models (limit N, default: 50)
    models top [N]              Show top N by popularity (default: 10)
    models filter <type> [N]    Filter models by type
    models search <query>       Search models by criteria
    models recommend            Show recommendations

EXAMPLES:
    ./rin start                     # Start RIN
    ./rin stop                      # Stop RIN
    ./rin models sync               # Sync all models
    ./rin models list 25            # List top 25 models
    ./rin models top 10             # Show top 10 models
    ./rin models filter vision 20   # Show 20 vision models
    ./rin status                    # Check system status
    ./rin logs                      # View all logs
    ./rin logs open-webui -f        # Follow Open WebUI logs

SERVICES:
    open-webui      - Open WebUI (Cortex)
    litellm         - LiteLLM (Router)
    searxng         - SearXNG (Vision)
    firecrawl       - FireCrawl (Digestion)
    n8n             - n8n (Reflex)
    qdrant          - Qdrant (Memory)
    redis           - Redis (Nervous System)
    playwright      - Playwright (Browser)

INTEGRATED TOOLS (Available in Open WebUI):
    searxng_search.py   - Anonymous web search via SearXNG
    tavily_search.py    - AI-optimized search via Tavily API (requires TAVILY_API_KEY)
    firecrawl_scraper.py - Web scraping via FireCrawl (self-hosted or cloud)
    qdrant_memory.py    - Long-term memory with RAG
    n8n_reflex.py       - Workflow automation integration

API KEYS CONFIGURATION:
    Configure in .env file:
    - TAVILY_API_KEY       (Optional - for Tavily search, get from https://tavily.com)
    - FIRECRAWL_API_KEY    (Auto-generated for self-hosted, or use cloud API key)
    - OPENAI_API_KEY       (Required for GPT models)
    - ANTHROPIC_API_KEY    (Required for Claude models)
    - OPENROUTER_API_KEY   (Optional - access to 20+ models)

For more information, visit:
    https://github.com/radkisson/Rhyzomic-Intelligence-Node-RIN-
EOF
}

# --- Main Command Router ---

main() {
    local command="${1:-help}"
    shift || true
    
    case "$command" in
        start)
            cmd_start "$@"
            ;;
        stop)
            cmd_stop "$@"
            ;;
        restart)
            cmd_restart "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        logs)
            cmd_logs "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        upgrade)
            cmd_upgrade "$@"
            ;;
        backup)
            cmd_backup "$@"
            ;;
        restore)
            cmd_restore "$@"
            ;;
        ps)
            cmd_ps "$@"
            ;;
        exec)
            cmd_exec "$@"
            ;;
        clean)
            cmd_clean "$@"
            ;;
        models)
            cmd_models "$@"
            ;;
        version)
            cmd_version "$@"
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

# Execute main function
main "$@"
